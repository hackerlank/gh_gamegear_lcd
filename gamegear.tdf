SUBDESIGN gamegear
(
 red_out[3..0]		: OUTPUT;  -- red video output
 green_out[3..0]	: OUTPUT;  -- green video output
 blue_out[3..0]		: OUTPUT;  -- blue video output
 d_in[3..0]			: INPUT;   -- multiplexed data input
 csync, hsync		: INPUT;
 pix_clk			: INPUT;   -- 32Mhz master clock
 sc_out				: OUTPUT;  % Subcarrier output for video enc. Generated by dividing
                                 pix_clk by 9. %
 cs_out          	: OUTPUT;  -- buffered composite sync output
 en_in				: INPUT ;  -- /OE, when low enable outputs
 en_out				: OUTPUT;  -- inverse of /OE, to switch off +5v rail
)

VARIABLE
ffa, ffb, ffc		: DFF;
red_dff[3..0]		: DFF;
green_dff[3..0]		: DFF;
blue_dff[3..0]		: DFF;
div_nine[3..0]		: DFF;
red_tri[3..0]		: TRI;
green_tri[3..0]		: TRI;
blue_tri[3..0]		: TRI;
csync_tri			: TRI;
sc_tri				: TRI;

BEGIN
ffa.d = !ffc.q;
ffb.d = ffa.q;
ffc.d = ffb.q;
ffa.clk = pix_clk;
ffb.clk = pix_clk;
ffc.clk = pix_clk;
ffa.clrn = !hsync;
ffb.clrn = !hsync;
ffc.clrn = !hsync;
red_dff[].clk = ffa.q;
green_dff[].clk = ffc.q;
blue_dff[].clk = !ffb.q;
red_dff[].d = d_in[];
green_dff[].d = d_in[];
blue_dff[].d = d_in[];



div_nine[].clk = pix_clk;
IF div_nine[] >= 8 THEN div_nine[] = 0;
ELSE div_nine[].d = div_nine[].q + 1;
END IF;

IF div_nine[] >= 4 THEN sc_tri.in = vcc;
ELSE sc_tri.in = gnd;
END IF;

sc_out = sc_tri.out;
sc_tri.oe = !en_in;
-- csync_out = csync;

csync_tri.in = csync;
cs_out = csync_tri.out;
csync_tri.oe = !en_in;

red_tri[].in = red_dff[].q;
red_out[] = red_tri[].out;
red_tri[].oe = !en_in;

green_tri[].in = green_dff[].q;
green_out[] = green_tri[].out;
green_tri[].oe = !en_in;

blue_tri[].in = blue_dff[].q;
blue_out[] = blue_tri[].out;
blue_tri[].oe = !en_in;

en_out = !en_in;

END;
